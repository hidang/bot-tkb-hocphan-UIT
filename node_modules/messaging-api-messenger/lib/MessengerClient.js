"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;


var _crypto = _interopRequireDefault(require("crypto"));
var _querystring = _interopRequireDefault(require("querystring"));
var _url2 = _interopRequireDefault(require("url"));

var _axiosError = _interopRequireDefault(require("axios-error"));
var _formData = _interopRequireDefault(require("form-data"));
var _appendQuery = _interopRequireDefault(require("append-query"));
var _axios = _interopRequireDefault(require("axios"));
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash.get"));
var _invariant = _interopRequireDefault(require("invariant"));
var _isPlainObject = _interopRequireDefault(require("is-plain-object"));
var _lodash2 = _interopRequireDefault(require("lodash.omit"));
var _urlJoin = _interopRequireDefault(require("url-join"));
var _warning = _interopRequireDefault(require("warning"));

var _Messenger = _interopRequireDefault(require("./Messenger"));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _objectWithoutProperties(source, excluded) {if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];}}return target;}function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(source, true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(source).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}



























































function extractVersion(version) {
  if (version.startsWith('v')) {
    return version.slice(1);
  }
  return version;
}

function handleError(err) {
  if (err.response && err.response.data) {
    const error = (0, _lodash.default)(err, 'response.data.error', {});
    const msg = `Messenger API - ${error.code} ${error.type} ${error.message}`;
    throw new _axiosError.default(msg, err);
  }
  throw new _axiosError.default(err.message, err);
}

const debugRequest = (0, _debug.default)('messaging-api-messenger');

function onRequest({ method, url: _url, body }) {
  debugRequest(`${method} ${_url}`);
  if (body) {
    debugRequest('Outgoing request body:');
    debugRequest(JSON.stringify(body, null, 2));
  }
}

class MessengerClient {
  static connect(
  accessTokenOrConfig,
  version = '4.0')
  {
    return new MessengerClient(accessTokenOrConfig, version);
  }













  constructor(
  accessTokenOrConfig,
  version = '4.0')
  {_defineProperty(this, "_accessToken", void 0);_defineProperty(this, "_appId", void 0);_defineProperty(this, "_appSecret", void 0);_defineProperty(this, "_version", void 0);_defineProperty(this, "_onRequest", void 0);_defineProperty(this, "_axios", void 0);
    let origin;
    let skipAppSecretProof;
    if (accessTokenOrConfig && typeof accessTokenOrConfig === 'object') {
      const config = accessTokenOrConfig;

      this._accessToken = config.accessToken;
      (0, _invariant.default)(
      !config.version || typeof config.version === 'string',
      'Type of `version` must be string.');

      this._appId = config.appId;
      this._appSecret = config.appSecret;
      this._version = extractVersion(config.version || '4.0');
      this._onRequest = config.onRequest || onRequest;
      origin = config.origin;

      if (typeof config.skipAppSecretProof === 'boolean') {
        skipAppSecretProof = config.skipAppSecretProof;
      } else {
        skipAppSecretProof = this._appSecret == null;
      }
    } else {
      this._accessToken = accessTokenOrConfig;
      (0, _invariant.default)(
      typeof version === 'string',
      'Type of `version` must be string.');

      this._version = extractVersion(version);
      this._onRequest = onRequest;

      skipAppSecretProof = true;
    }

    this._axios = _axios.default.create({
      baseURL: `${origin || 'https://graph.facebook.com'}/v${this._version}/`,
      headers: { 'Content-Type': 'application/json' } });


    // add appsecret_proof to request
    if (!skipAppSecretProof) {
      (0, _invariant.default)(
      this._appSecret,
      'Must provide appSecret when skipAppSecretProof is false');

      const appSecret = this._appSecret;

      this._axios.interceptors.request.use(config => {
        const urlParts = _url2.default.parse(config.url, true);
        const accessToken = (0, _lodash.default)(
        urlParts,
        'query.access_token',
        this._accessToken);


        const appSecretProof = _crypto.default.
        createHmac('sha256', appSecret).
        update(accessToken, 'utf8').
        digest('hex');

        // eslint-disable-next-line no-param-reassign
        config.url = (0, _appendQuery.default)(config.url, {
          appsecret_proof: appSecretProof });


        return config;
      });
    }

    this._axios.interceptors.request.use(config => {
      this._onRequest({
        method: config.method,
        url: (0, _urlJoin.default)(config.baseURL, config.url),
        headers: _objectSpread({},
        config.headers.common, {},
        config.headers[config.method], {},
        (0, _lodash2.default)(config.headers, [
        'common',
        'get',
        'post',
        'put',
        'patch',
        'delete',
        'head'])),


        body: config.data });

      return config;
    });
  }

  get version() {
    return this._version;
  }

  get axios() {
    return this._axios;
  }

  get accessToken() {
    return this._accessToken;
  }

  get appSecret() {
    return this._appSecret;
  }

  /**
     * Get Page Info
     *
     * https://developers.facebook.com/docs/graph-api/using-graph-api
     * id, name
     */
  getPageInfo({
    access_token: customAccessToken } =
  {}) {
    return this._axios.
    get(`/me?access_token=${customAccessToken || this._accessToken}`).
    then(res => res.data, handleError);
  }

  /**
     * Debug Token
     *
     * https://developers.facebook.com/docs/facebook-login/access-tokens/debugging-and-error-handling
     */
  debugToken({
    access_token: customAccessToken } =
  {}) {
    (0, _invariant.default)(this._appId, 'App ID is required to debug token');
    (0, _invariant.default)(this._appSecret, 'App Secret is required to debug token');

    const accessToken = `${this._appId}|${this._appSecret}`;

    return this._axios.
    get(`/debug_token`, {
      params: {
        input_token: customAccessToken || this._accessToken,
        access_token: accessToken } }).


    then(res => res.data.data, handleError);
  }

  /**
     * Create Subscription
     *
     * https://developers.facebook.com/docs/graph-api/reference/app/subscriptions
     */
  createSubscription({
    app_id,
    object = 'page',
    callback_url,
    fields = [
    'messages',
    'messaging_postbacks',
    'messaging_optins',
    'messaging_referrals',
    'messaging_handovers',
    'messaging_policy_enforcement'],

    include_values,
    verify_token,
    access_token: appAccessToken })








  {
    (0, _warning.default)(
    !app_id,
    'Provide App ID in the function is deprecated. Provide it in `MessengerClient.connect({ appId, ... })` instead');


    const appId = app_id || this._appId;

    (0, _invariant.default)(appId, 'App ID is required to create subscription');
    (0, _invariant.default)(
    this._appSecret || appAccessToken,
    'App Secret or App Token is required to create subscription');


    const accessToken =
    appAccessToken || `${appId}|${this._appSecret}`;

    return this._axios.
    post(`/${appId}/subscriptions?access_token=${accessToken}`, {
      object,
      callback_url,
      fields: fields.join(','),
      include_values,
      verify_token }).

    then(res => res.data, handleError);
  }

  /**
     * Get Subscriptions
     *
     * https://developers.facebook.com/docs/graph-api/reference/app/subscriptions
     */
  getSubscriptions({
    app_id,
    access_token: appAccessToken } =



  {}) {
    (0, _warning.default)(
    !app_id,
    'Provide App ID in the function is deprecated. Provide it in `MessengerClient.connect({ appId, ... })` instead');


    const appId = app_id || this._appId;
    (0, _invariant.default)(appId, 'App ID is required to get subscriptions');
    (0, _invariant.default)(
    this._appSecret || appAccessToken,
    'App Secret or App Token is required to get subscriptions');


    const accessToken =
    appAccessToken || `${appId}|${this._appSecret}`;

    return this._axios.
    get(`/${appId}/subscriptions?access_token=${accessToken}`).
    then(res => res.data.data, handleError);
  }

  /**
     * Extract page subscription from subscriptions
     *
     * https://developers.facebook.com/docs/graph-api/reference/app/subscriptions
     */
  getPageSubscription({
    app_id,
    access_token: appAccessToken } =



  {}) {
    (0, _warning.default)(
    !app_id,
    'Provide App ID in the function is deprecated. Provide it in `MessengerClient.connect({ appId, ... })` instead');


    const appId = app_id || this._appId;
    (0, _invariant.default)(appId, 'App ID is required to get subscription');
    (0, _invariant.default)(
    this._appSecret || appAccessToken,
    'App Secret or App Token is required to get subscription');


    const accessToken =
    appAccessToken || `${appId}|${this._appSecret}`;

    return this.getSubscriptions({
      app_id: appId,
      access_token: accessToken }).
    then(
    (subscriptions) =>
    subscriptions.filter(
    subscription => subscription.object === 'page')[
    0] || null);

  }

  /**
     *  Messaging Feature Review API
     *
     *  https://developers.facebook.com/docs/messenger-platform/reference/messaging-feature-review-api
     */
  getMessagingFeatureReview({
    access_token: customAccessToken } =
  {}) {
    return this._axios.
    get(
    `/me/messaging_feature_review?access_token=${customAccessToken ||
    this._accessToken}`).

    then(res => res.data.data, handleError);
  }

  /**
     * Get User Profile
     *
     * https://www.quora.com/How-connect-Facebook-user-id-to-sender-id-in-the-Facebook-messenger-platform
     * first_name, last_name, profile_pic, locale, timezone, gender
     */
  getUserProfile(
  userId,
  {
    access_token: customAccessToken,
    fields = ['id', 'name', 'first_name', 'last_name', 'profile_pic'] } =
  {})
  {
    return this._axios.
    get(
    `/${userId}?fields=${fields.join(
    ',')
    }&access_token=${customAccessToken || this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Messenger Profile
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api
     */
  getMessengerProfile(
  fields,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    get(
    `/me/messenger_profile?fields=${fields.join(
    ',')
    }&access_token=${customAccessToken || this._accessToken}`).

    then(res => res.data.data, handleError);
  }

  setMessengerProfile(
  profile,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/me/messenger_profile?access_token=${customAccessToken ||
    this._accessToken}`,
    profile).

    then(res => res.data, handleError);
  }

  deleteMessengerProfile(
  fields,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    delete(
    `/me/messenger_profile?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      data: {
        fields } }).



    then(res => res.data, handleError);
  }

  /**
     * Get Started Button
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/get-started-button
     */
  getGetStarted(
  options = {})
  {
    return this.getMessengerProfile(['get_started'], options).then((res) =>
    res[0] ? res[0].get_started : null);

  }

  setGetStarted(
  payload,
  options = {})
  {
    return this.setMessengerProfile(
    {
      get_started: {
        payload } },


    options);

  }

  deleteGetStarted(options = {}) {
    return this.deleteMessengerProfile(['get_started'], options);
  }

  /**
     * Persistent Menu
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/persistent-menu
     */
  getPersistentMenu(
  options = {})
  {
    return this.getMessengerProfile(['persistent_menu'], options).then((res) =>
    res[0] ? res[0].persistent_menu : null);

  }

  setPersistentMenu(
  menuItems,
  _ref =





  {})
  {let { composer_input_disabled: composerInputDisabled = false } = _ref,options = _objectWithoutProperties(_ref, ["composer_input_disabled"]);
    // menuItems is in type PersistentMenu
    if (menuItems.some(item => item.locale === 'default')) {
      return this.setMessengerProfile(
      {
        persistent_menu: menuItems },

      options);

    }

    // menuItems is in type Array<MenuItem>
    return this.setMessengerProfile(
    {
      persistent_menu: [
      {
        locale: 'default',
        composer_input_disabled: composerInputDisabled,
        call_to_actions: menuItems }] },



    options);

  }

  deletePersistentMenu(
  options = {})
  {
    return this.deleteMessengerProfile(['persistent_menu'], options);
  }

  /**
     * Greeting Text
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/greeting
     */
  getGreeting(options = {}) {
    return this.getMessengerProfile(['greeting'], options).then((res) =>
    res[0] ? res[0].greeting : null);

  }

  setGreeting(
  greeting,
  options = {})
  {
    if (typeof greeting === 'string') {
      return this.setMessengerProfile(
      {
        greeting: [
        {
          locale: 'default',
          text: greeting }] },



      options);

    }

    return this.setMessengerProfile(
    {
      greeting },

    options);

  }

  deleteGreeting(options = {}) {
    return this.deleteMessengerProfile(['greeting'], options);
  }

  /**
     * Whitelisted Domains
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/domain-whitelisting
     */
  getWhitelistedDomains(
  options = {})
  {
    return this.getMessengerProfile(['whitelisted_domains'], options).then(
    res => res[0] ? res[0].whitelisted_domains : null);

  }

  setWhitelistedDomains(
  domains,
  options = {})
  {
    return this.setMessengerProfile(
    {
      whitelisted_domains: domains },

    options);

  }

  deleteWhitelistedDomains(
  options = {})
  {
    return this.deleteMessengerProfile(['whitelisted_domains'], options);
  }

  /**
     * Account Linking URL
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/account-linking-url
     */
  getAccountLinkingURL(
  options = {})
  {
    return this.getMessengerProfile(['account_linking_url'], options).then(
    res => res[0] ? res[0] : null);

  }

  setAccountLinkingURL(
  linkingURL,
  options = {})
  {
    return this.setMessengerProfile(
    {
      account_linking_url: linkingURL },

    options);

  }

  deleteAccountLinkingURL(
  options = {})
  {
    return this.deleteMessengerProfile(['account_linking_url'], options);
  }

  /**
     * Payment Settings
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/payment-settings
     */
  getPaymentSettings(
  options = {})
  {
    return this.getMessengerProfile(['payment_settings'], options).then((res) =>
    res[0] ? res[0] : null);

  }

  setPaymentPrivacyPolicyURL(
  privacyURL,
  options = {})
  {
    return this.setMessengerProfile(
    {
      payment_settings: {
        privacy_url: privacyURL } },


    options);

  }

  setPaymentPublicKey(
  key,
  options = {})
  {
    return this.setMessengerProfile(
    {
      payment_settings: {
        public_key: key } },


    options);

  }

  setPaymentTestUsers(
  users,
  options = {})
  {
    return this.setMessengerProfile(
    {
      payment_settings: {
        test_users: users } },


    options);

  }

  deletePaymentSettings(
  options = {})
  {
    return this.deleteMessengerProfile(['payment_settings'], options);
  }

  /**
     * Target Audience
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/target-audience
     */
  getTargetAudience(
  options = {})
  {
    return this.getMessengerProfile(['target_audience'], options).then((res) =>
    res[0] ? res[0] : null);

  }

  setTargetAudience(
  type,
  whitelist = [],
  blacklist = [],
  options = {})
  {
    return this.setMessengerProfile(
    {
      target_audience: {
        audience_type: type,
        countries: {
          whitelist,
          blacklist } } },



    options);

  }

  deleteTargetAudience(
  options = {})
  {
    return this.deleteMessengerProfile(['target_audience'], options);
  }

  /**
     * Chat Extension Home URL
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messenger-profile-api/home-url
     */
  getHomeURL(options = {}) {
    return this.getMessengerProfile(['home_url'], options).then((res) =>
    res[0] ? res[0] : null);

  }

  setHomeURL(
  homeURL,
  {
    webview_share_button,
    in_test },




  options = {})
  {
    return this.setMessengerProfile(
    {
      home_url: {
        url: homeURL,
        webview_height_ratio: 'tall',
        in_test,
        webview_share_button } },


    options);

  }

  deleteHomeURL(options = {}) {
    return this.deleteMessengerProfile(['home_url'], options);
  }

  /**
     * Message tags
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags
     */
  getMessageTags({
    access_token: customAccessToken } =
  {}) {
    return this._axios.
    get(
    `/page_message_tags?access_token=${customAccessToken ||
    this._accessToken}`).

    then(res => res.data.data, handleError);
  }

  /**
     * Send API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/send-api
     */
  // TODO: body flowtype
  sendRawBody(body) {
    const { access_token: customAccessToken } = body;

    return this._axios.
    post(
    `/me/messages?access_token=${customAccessToken || this._accessToken}`,
    body).

    then(res => res.data, handleError);
  }

  sendMessage(
  idOrRecipient,
  message,
  options = {})
  {
    const recipient =
    typeof idOrRecipient === 'string' ?
    {
      id: idOrRecipient } :

    idOrRecipient;

    let messageType = 'UPDATE';

    if (options.messaging_type) {
      messageType = options.messaging_type;
    } else if (options.tag) {
      messageType = 'MESSAGE_TAG';
    }

    return this.sendRawBody(_objectSpread({
      messaging_type: messageType,
      recipient,
      message: _Messenger.default.createMessage(message, options) },
    (0, _lodash2.default)(options, 'quick_replies')));

  }

  sendMessageFormData(
  recipient,
  formdata,
  options = {})
  {
    const recipientObject =
    typeof recipient === 'string' ?
    {
      id: recipient } :

    recipient;

    let messageType = 'UPDATE';
    if (options.messaging_type) {
      messageType = options.messaging_type;
    } else if (options.tag) {
      messageType = 'MESSAGE_TAG';
    }

    formdata.append('messaging_type', messageType);
    formdata.append('recipient', JSON.stringify(recipientObject));

    return this._axios.
    post(
    `/me/messages?access_token=${options.access_token ||
    this._accessToken}`,
    formdata,
    {
      headers: formdata.getHeaders() }).


    then(res => res.data, handleError);
  }

  /**
     * Content Types
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages#content_types
     */
  sendAttachment(
  recipient,
  attachment,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createAttachment(attachment, options),
    options);

  }

  sendText(
  recipient,
  text,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createText(text, options),
    options);

  }

  sendAudio(
  recipient,
  audio,
  options)
  {
    const message = _Messenger.default.createAudio(audio, options);

    if (message && (0, _isPlainObject.default)(message)) {
      return this.sendMessage(recipient, message, options);
    }

    // $FlowFixMe
    return this.sendMessageFormData(recipient, message, options);
  }

  sendImage(
  recipient,
  image,
  options)
  {
    const message = _Messenger.default.createImage(image, options);

    if (message && (0, _isPlainObject.default)(message)) {
      return this.sendMessage(recipient, message, options);
    }

    // $FlowFixMe
    return this.sendMessageFormData(recipient, message, options);
  }

  sendVideo(
  recipient,
  video,
  options)
  {
    const message = _Messenger.default.createVideo(video, options);

    if (message && (0, _isPlainObject.default)(message)) {
      return this.sendMessage(recipient, message, options);
    }

    // $FlowFixMe
    return this.sendMessageFormData(recipient, message, options);
  }

  sendFile(
  recipient,
  file,
  options)
  {
    const message = _Messenger.default.createFile(file, options);

    if (message && (0, _isPlainObject.default)(message)) {
      return this.sendMessage(recipient, message, options);
    }

    // $FlowFixMe
    return this.sendMessageFormData(recipient, message, options);
  }

  /**
     * Message Templates
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/templates
     */
  sendTemplate(
  recipient,
  payload,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createTemplate(payload, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/button
  sendButtonTemplate(
  recipient,
  text,
  buttons,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createButtonTemplate(text, buttons, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/generic
  sendGenericTemplate(
  recipient,
  elements,
  _ref2 =






  {})
  {let { // $FlowFixMe
      image_aspect_ratio = 'horizontal' } = _ref2,options = _objectWithoutProperties(_ref2, ["image_aspect_ratio"]);return this.sendMessage(
    recipient,
    _Messenger.default.createGenericTemplate(elements, _objectSpread({},
    options, {
      image_aspect_ratio })),

    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/list
  sendListTemplate(
  recipient,
  elements,
  buttons,
  _ref3 =






  {})
  {let { // $FlowFixMe
      top_element_style = 'large' } = _ref3,options = _objectWithoutProperties(_ref3, ["top_element_style"]);return this.sendMessage(
    recipient,
    _Messenger.default.createListTemplate(elements, buttons, _objectSpread({},
    options, {
      top_element_style })),

    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/open-graph
  sendOpenGraphTemplate(
  recipient,
  elements,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createOpenGraphTemplate(elements, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/receipt
  sendReceiptTemplate(
  recipient,
  attrs,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createReceiptTemplate(attrs, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/media
  sendMediaTemplate(
  recipient,
  elements,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createMediaTemplate(elements, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#boarding_pass
  sendAirlineBoardingPassTemplate(
  recipient,
  attrs,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createAirlineBoardingPassTemplate(attrs, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#check_in
  sendAirlineCheckinTemplate(
  recipient,
  attrs,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createAirlineCheckinTemplate(attrs, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#itinerary
  sendAirlineItineraryTemplate(
  recipient,
  attrs,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createAirlineItineraryTemplate(attrs, options),
    options);

  }

  // https://developers.facebook.com/docs/messenger-platform/send-messages/template/airline#update
  sendAirlineUpdateTemplate(
  recipient,
  attrs,
  options)
  {
    return this.sendMessage(
    recipient,
    _Messenger.default.createAirlineUpdateTemplate(attrs, options),
    options);

  }

  /**
     * Typing
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/sender-actions
     */
  sendSenderAction(
  idOrRecipient,
  action,
  { access_token: customAccessToken } = {})
  {
    const recipient =
    typeof idOrRecipient === 'string' ?
    {
      id: idOrRecipient } :

    idOrRecipient;
    return this.sendRawBody({
      recipient,
      sender_action: action,
      access_token: customAccessToken });

  }

  markSeen(
  recipient,
  options = {})
  {
    return this.sendSenderAction(recipient, 'mark_seen', options);
  }

  typingOn(
  recipient,
  options = {})
  {
    return this.sendSenderAction(recipient, 'typing_on', options);
  }

  typingOff(
  recipient,
  options = {})
  {
    return this.sendSenderAction(recipient, 'typing_off', options);
  }

  /**
     * Send Batch Request
     *
     * https://developers.facebook.com/docs/graph-api/making-multiple-requests
     */
  sendBatch(
  batch,
  { access_token: customAccessToken } = {})
  {
    (0, _invariant.default)(
    batch.length <= 50,
    'limit the number of requests which can be in a batch to 50');


    const responseAccessPaths = batch.map(item => item.responseAccessPath);

    const bodyEncodedbatch = batch.map(item => {
      if (item.body) {
        return _objectSpread({},
        (0, _lodash2.default)(item, 'responseAccessPath'), {
          // $FlowFixMe item.body should not possible as undefined.
          body: Object.keys(item.body).
          map(key => {
            // $FlowFixMe item.body should not possible as undefined.
            const val = item.body[key];
            return `${encodeURIComponent(key)}=${encodeURIComponent(
            typeof val === 'object' ? JSON.stringify(val) : val)
            }`;
          }).
          join('&') });

      }
      return (0, _lodash2.default)(item, 'responseAccessPath');
    });

    return this._axios.
    post('/', {
      access_token: customAccessToken || this._accessToken,
      batch: bodyEncodedbatch }).

    then(
    (res) =>
    res.data.map((datum, index) => {
      if (responseAccessPaths[index] && datum.body) {
        return _objectSpread({},
        datum, {
          body: JSON.stringify(
          (0, _lodash.default)(JSON.parse(datum.body), responseAccessPaths[index])) });


      }
      return datum;
    }),
    handleError);

  }

  /**
     * Broadcast API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/broadcast-api
     */

  /**
         * Create Message Creative
         *
         * https://developers.facebook.com/docs/messenger-platform/reference/sponsored-messages#creative
         */
  createMessageCreative(
  messages = [],
  { access_token: customAccessToken } = {})
  {
    (0, _warning.default)(false, 'createMessageCreative: Broadcast API is deprecated.');

    return this._axios.
    post(
    `/me/message_creatives?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      messages }).


    then(res => res.data, handleError);
  }

  /**
     * Send Broadcast Message
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages#sending
     */
  sendBroadcastMessage(messageCreativeId, options = {}) {
    (0, _warning.default)(false, 'sendBroadcastMessage: Broadcast API is deprecated.');

    return this._axios.
    post(
    `/me/broadcast_messages?access_token=${options.access_token ||
    this._accessToken}`, _objectSpread({

      message_creative_id: messageCreativeId },
    options)).


    then(res => res.data, handleError);
  }

  cancelBroadcast(broadcastId, options = {}) {
    (0, _warning.default)(false, 'cancelBroadcast: Broadcast API is deprecated.');

    return this._axios.
    post(
    `/${broadcastId}?access_token=${options.access_token ||
    this._accessToken}`,
    {
      operation: 'cancel' }).


    then(res => res.data, handleError);
  }

  getBroadcast(broadcastId, options = {}) {
    (0, _warning.default)(false, 'getBroadcast: Broadcast API is deprecated.');

    return this._axios.
    get(
    `/${broadcastId}?fields=scheduled_time,status&access_token=${options.access_token ||
    this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Send Sponsored Message
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/sponsored-messages#message
     */
  sendSponsoredMessage(adAccountId, message) {
    return this._axios.
    post(
    `/act_${adAccountId}/sponsored_message_ads?access_token=${this._accessToken}`,
    message).

    then(res => res.data, handleError);
  }

  /**
     * Label API
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts
     */

  /**
         * Create Label
         *
         * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#create_label
         */
  createLabel(
  name,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/me/custom_labels?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      name }).


    then(res => res.data, handleError);
  }

  /**
     * Associating a Label to a PSID
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#associate_label
     */
  associateLabel(
  userId,
  labelId,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/${labelId}/label?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      user: userId }).


    then(res => res.data, handleError);
  }

  /**
     * Removing a Label From a PSID
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#associate_label
     */
  dissociateLabel(
  userId,
  labelId,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    delete(
    `/${labelId}/label?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      data: { user: userId } }).


    then(res => res.data, handleError);
  }

  /**
     * Retrieving Labels Associated with a PSID
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#get_all_labels
     */
  getAssociatedLabels(
  userId,
  options = {})
  {
    const fields = options.fields ? options.fields.join(',') : 'name';
    return this._axios.
    get(
    `/${userId}/custom_labels?fields=${fields}&access_token=${options.access_token ||
    this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Retrieving Label Details
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#get_label_details
     */
  getLabelDetails(
  labelId,
  options = {})
  {
    const fields = options.fields ? options.fields.join(',') : 'name';
    return this._axios.
    get(
    `/${labelId}?fields=${fields}&access_token=${options.access_token ||
    this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Retrieving a List of All Labels
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#get_all_labels
     */
  getLabelList(
  options = {})
  {
    const fields = options.fields ? options.fields.join(',') : 'name';
    return this._axios.
    get(
    `/me/custom_labels?fields=${fields}&access_token=${options.access_token ||
    this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Deleting a Label
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/target-broadcasts#delete_label
     */
  deleteLabel(
  labelId,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    delete(
    `/${labelId}?access_token=${customAccessToken || this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Starting a Reach Estimation
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/estimate-reach#start
     */
  startReachEstimation(
  customLabelId,
  { access_token: customAccessToken } = {})
  {
    (0, _warning.default)(false, 'startReachEstimation: Broadcast API is deprecated.');

    return this._axios.
    post(
    `/me/broadcast_reach_estimations?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      custom_label_id: customLabelId }).


    then(res => res.data, handleError);
  }

  /**
     * Retrieving a Reach Estimate
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/estimate-reach#get
     */
  getReachEstimate(
  reachEstimationId,
  { access_token: customAccessToken } = {})
  {
    (0, _warning.default)(false, 'getReachEstimate: Broadcast API is deprecated.');

    return this._axios.
    get(
    `/${reachEstimationId}?access_token=${customAccessToken ||
    this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Broadcast Metrics
     *
     * Once a broadcast has been delivered, you can find out the total number of people it reached.
     * https://developers.facebook.com/docs/messenger-platform/send-messages/broadcast-messages/#metrics
     */
  getBroadcastMessagesSent(
  broadcastId,
  { access_token: customAccessToken } = {})
  {
    (0, _warning.default)(false, 'getBroadcastMessagesSent: Broadcast API is deprecated.');

    return this._axios.
    post(
    `/${broadcastId}/insights/messages_sent?access_token=${customAccessToken ||
    this._accessToken}`).

    then(res => res.data.data, handleError);
  }

  /**
     * Upload API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/attachment-upload-api
     */
  uploadAttachment(
  type,
  attachment,
  options = {})
  {
    const args = [];

    const isReusable = options.is_reusable || false;

    if (typeof attachment === 'string') {
      args.push({
        message: {
          attachment: {
            type,
            payload: {
              url: attachment,
              is_reusable: isReusable } } } });




    } else {
      const form = new _formData.default();

      form.append(
      'message',
      JSON.stringify({
        attachment: {
          type,
          payload: {
            is_reusable: isReusable } } }));





      form.append('filedata', attachment, (0, _lodash2.default)(options, ['is_reusable']));

      args.push(form, {
        headers: form.getHeaders(),
        maxContentLength: Infinity // Facebook limit is 25MB, set a bigger value and let Facebook reject it
      });
    }

    return this._axios.
    post(
    `/me/message_attachments?access_token=${options.access_token ||
    this._accessToken}`,
    ...args).

    then(res => res.data, handleError);
  }

  uploadAudio(attachment, options) {
    return this.uploadAttachment('audio', attachment, options);
  }

  uploadImage(attachment, options) {
    return this.uploadAttachment('image', attachment, options);
  }

  uploadVideo(attachment, options) {
    return this.uploadAttachment('video', attachment, options);
  }

  uploadFile(attachment, options) {
    return this.uploadAttachment('file', attachment, options);
  }

  /**
     * Messenger Code API
     *
     * https://developers.facebook.com/docs/messenger-platform/discovery/messenger-codes
     */
  generateMessengerCode(options = {}) {
    (0, _warning.default)(false, 'generateMessengerCode: Messenger Code is deprecated.');

    return this._axios.
    post(
    `/me/messenger_codes?access_token=${options.access_token ||
    this._accessToken}`, _objectSpread({

      type: 'standard' },
    options)).


    then(res => res.data, handleError);
  }

  /**
     * Handover Protocol API
     *
     * https://developers.facebook.com/docs/messenger-platform/handover-protocol
     */

  /**
         * Pass Thread Control
         *
         * https://developers.facebook.com/docs/messenger-platform/reference/handover-protocol/pass-thread-control
         */
  passThreadControl(
  recipientId,
  targetAppId,
  metadata,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/me/pass_thread_control?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      recipient: { id: recipientId },
      target_app_id: targetAppId,
      metadata }).


    then(res => res.data, handleError);
  }

  passThreadControlToPageInbox(
  recipientId,
  metadata,
  options = {})
  {
    return this.passThreadControl(
    recipientId,
    263902037430900,
    metadata,
    options);

  }

  /**
     * Take Thread Control
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/handover-protocol/take-thread-control
     */
  takeThreadControl(
  recipientId,
  metadata,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/me/take_thread_control?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      recipient: { id: recipientId },
      metadata }).


    then(res => res.data, handleError);
  }

  /**
     * Request Thread Control
     *
     * https://developers.facebook.com/docs/messenger-platform/handover-protocol/request-thread-control/
     */
  requestThreadControl(
  recipientId,
  metadata,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/me/request_thread_control?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      recipient: { id: recipientId },
      metadata }).


    then(res => res.data, handleError);
  }

  /**
     * Secondary Receivers List
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/handover-protocol/secondary-receivers
     */
  getSecondaryReceivers({
    access_token: customAccessToken } =
  {}) {
    return this._axios.
    get(
    `/me/secondary_receivers?fields=id,name&access_token=${customAccessToken ||
    this._accessToken}`).

    then(res => res.data.data, handleError);
  }

  /**
     * Getting the Thread Owner
     *
     * https://developers.facebook.com/docs/messenger-platform/handover-protocol/get-thread-owner
     */
  getThreadOwner(
  recipientId,
  { access_token: customAccessToken } = {})
  {
    (0, _warning.default)(
    false,
    '`getThreadOwner` is currently in open beta, and is subject to change. See details in  https://developers.facebook.com/docs/messenger-platform/handover-protocol/get-thread-owner');

    return this._axios.
    get(
    `/me/thread_owner?recipient=${recipientId}&access_token=${customAccessToken ||
    this._accessToken}`).

    then(res => res.data.data[0].thread_owner, handleError);
  }

  /**
     * Page Messaging Insights API
     *
     * https://developers.facebook.com/docs/messenger-platform/reference/messaging-insights-api
     */
  getInsights(metrics, options = {}) {
    return this._axios.
    get(
    `/me/insights/?${_querystring.default.stringify(_objectSpread({
      metric: metrics.join(','),
      access_token: options.access_token || this._accessToken },
    options))
    }`).

    then(res => res.data.data, handleError);
  }

  getBlockedConversations(options = {}) {
    return this.getInsights(
    ['page_messages_blocked_conversations_unique'],
    options).
    then(result => result[0]);
  }

  getReportedConversations(options = {}) {
    return this.getInsights(
    ['page_messages_reported_conversations_unique'],
    options).
    then(result => result[0]);
  }

  getOpenConversations(options = {}) {
    // The metrics used here was replaced by the metrics used in getTotalMessagingConnections()
    (0, _warning.default)(
    false,
    'getOpenConversations() was deprecated, please use getTotalMessagingConnections() now.');

    return this.getTotalMessagingConnections(options);
  }

  getTotalMessagingConnections(options = {}) {
    // https://developers.facebook.com/docs/messenger-platform/reference/messaging-insights-api?locale=en_US#metrics
    // This metrics replaces the page_messages_open_conversations_unique metric, which was deprecated on May 11, 2018.

    return this.getInsights(
    ['page_messages_total_messaging_connections'],
    options).
    then(result => result[0]);
  }

  getNewConversations(options = {}) {
    return this.getInsights(
    ['page_messages_new_conversations_unique'],
    options).
    then(result => result[0]);
  }

  /**
     * Built-in NLP API
     *
     * https://developers.facebook.com/docs/messenger-platform/built-in-nlp
     */
  setNLPConfigs(
  config = {},
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(`/me/nlp_configs?${_querystring.default.stringify(config)}`, {
      access_token: customAccessToken || this._accessToken }).

    then(res => res.data, handleError);
  }

  enableNLP(options = {}) {
    return this.setNLPConfigs({ nlp_enabled: true }, options);
  }

  disableNLP(options = {}) {
    return this.setNLPConfigs({ nlp_enabled: false }, options);
  }

  /**
     * Logging Custom Events
     *
     * https://developers.facebook.com/docs/app-events/bots-for-messenger#logging-custom-events
     */
  logCustomEvents({
    app_id,
    page_id,
    page_scoped_user_id,
    events,
    access_token: customAccessToken })






  {
    return this._axios.
    post(
    `/${app_id}/activities?access_token=${customAccessToken ||
    this._accessToken}`,
    {
      event: 'CUSTOM_APP_EVENTS',
      custom_events: JSON.stringify(events),
      advertiser_tracking_enabled: 0,
      application_tracking_enabled: 0,
      extinfo: JSON.stringify(['mb1']),
      page_id,
      page_scoped_user_id }).


    then(res => res.data, handleError);
  }

  /**
     * https://developers.facebook.com/docs/messenger-platform/identity/id-matching#examples
     */
  getUserField({
    field,
    user_id,
    app_secret,
    app,
    page,
    access_token: customAccessToken })







  {
    const accessToken = customAccessToken || this._accessToken;

    // $appsecret_proof= hash_hmac('sha256', $access_token, $app_secret);
    const appsecretProof = _crypto.default.
    createHmac('sha256', app_secret).
    update(accessToken).
    digest('hex');

    const appQueryString = app ? `&app=${app}` : '';
    const pageQueryString = page ? `&page=${page}` : '';

    return this._axios.
    get(
    `/${user_id}/${field}?access_token=${accessToken}&appsecret_proof=${appsecretProof}${appQueryString}${pageQueryString}`).

    then(res => res.data, handleError);
  }

  /**
     * Given a user ID for a bot in Messenger, retrieve the IDs for apps owned by the same business
     */
  getIdsForApps({
    user_id,
    app_secret,
    app,
    page,
    access_token })






  {
    return this.getUserField({
      field: 'ids_for_apps',
      user_id,
      app_secret,
      app,
      page,
      access_token });

  }

  /**
     * Given a user ID for a Page (associated with a bot), retrieve the IDs for other Pages owned by the same business
     */
  getIdsForPages({
    user_id,
    app_secret,
    app,
    page,
    access_token })






  {
    return this.getUserField({
      field: 'ids_for_pages',
      user_id,
      app_secret,
      app,
      page,
      access_token });

  }

  /**
     * Personas API
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas
     */

  /**
         * Creating a Persona
         *
         * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#create
         */
  createPersona(
  persona,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    post(
    `/me/personas?access_token=${customAccessToken || this._accessToken}`,
    persona).

    then(res => res.data, handleError);
  }

  /**
     * Retrieving a Persona
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#get
     */
  getPersona(
  personaId,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    get(
    `/${personaId}?access_token=${customAccessToken || this._accessToken}`).

    then(res => res.data, handleError);
  }

  /**
     * Retrieving All Available Personas
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#retrieve_all
     */

  getPersonas(
  cursor,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    get(
    `/me/personas?access_token=${customAccessToken || this._accessToken}${
    cursor ? `&after=${cursor}` : ''
    }`).

    then(res => res.data, handleError);
  }

  async getAllPersonas({
    access_token: customAccessToken } =
  {}) {
    let allPersonas = [];
    let cursor;

    do {
      // eslint-disable-next-line no-await-in-loop
      const { data, paging } = await this.getPersonas(cursor, {
        access_token: customAccessToken });

      allPersonas = allPersonas.concat(data);
      cursor = paging ? paging.cursors.after : null;
    } while (cursor);

    return allPersonas;
  }

  /**
     * Deleting a Persona
     *
     * https://developers.facebook.com/docs/messenger-platform/send-messages/personas/#remove
     */
  deletePersona(
  personaId,
  { access_token: customAccessToken } = {})
  {
    return this._axios.
    delete(
    `/${personaId}?access_token=${customAccessToken || this._accessToken}`).

    then(res => res.data, handleError);
  }}exports.default = MessengerClient;